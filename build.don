valgrind = false
gdb = '{gdb -q --args}

compile(datadir:@data/ extraflags:{} linkflags:{} optimize:false)
   ofiles = cc(@src/*.c
               flags:'{$("-DDATADIR=\""datadir"\"")
                       $(valgrind ? '-DVALGRIND : '-DNVALGRIND)
                       -ggdb3 -rdynamic -std=c89 -pedantic
                       -Wno-error=unused-parameter -Wno-error=unused-variable
                       -Wno-error=unused-function -Wall -Wextra -Wformat=2
                       -Winit-self -Wmissing-include-dirs -Wswitch-enum
                       -Wsync-nand -Wunused -Wstrict-overflow=5 -Wfloat-equal
                       -Wundef -Wshadow -Wunsafe-loop-optimizations
                       -Wbad-function-cast -Wc++-compat -Wcast-align
                       -Wwrite-strings -Wconversion -Wlogical-op
                       -Waggregate-return -Wstrict-prototypes
                       -Wold-style-definition -Wmissing-prototypes
                       -Wmissing-declarations -Wmissing-noreturn
                       -Wmissing-format-attribute -Wnormalized=nfc -Wpacked
                       -Wpacked-bitfield-compat -Wredundant-decls
                       -Wnested-externs -Wunreachable-code
                       -Wno-error=unreachable-code -Winline -Winvalid-pch
                       -Wdisabled-optimization -Wstack-protector -pipe
                       -march=native}::(optimize ? '{-O2} : '{-DDEBUG -O0})::extraflags)
   return link(ofiles flags:linkflags name:'don)

run(args... output:true)
   if valgrind
      logfile = @valgrind-log
      out exitcode = exec('valgrind '-q '--leak-check=full '--show-reachable=yes
                          "--log-file="logfile args
                          env:{'XDG_CACHE_HOME @tempcache}
                          fail:false echo:output echoStderr:output)
      log = read(logfile)
      rm(logfile)
      if (exitcode != 0 || contains(log "** Assertion failed")) && !contains(log "== Process terminating")
         l = lines(log)
         log = ""
         copy = false
         for line in l
            if startsWith(line '*)
               log = log""line"\n"
               copy = false
            else
               if contains(line "==    ") && copy
                  log = log""line"\n"
               else
                  if contains(line 'VALGRIND_PRINTF_BACKTRACE)
                     log = log""line"\n"
                     copy = true
                  else
                     copy = false
      out = {out[0] out[1]""log}
      if output && log != ""
         echo(log)
   else
      out exitcode = exec(args env:{'XDG_CACHE_HOME @tempcache}
                          fail:false echo:output echoStderr:output)
   return out exitcode

dotest(debug:false)
   program = compile()
   passcount = 0
   failcount = 0
   hasOutput = false
   for f in @test/*
      test = read(f)
      targets = {'default}
      expected = null
      if test[0] == '#
         lines = split(test "\n")
         command = split(lines[0] " ")
         if command[0] == '#fail:
            expected = ""
            maxFailLine = 1
            while maxFailLine < size(lines) && size(lines[maxFailLine]) && lines[maxFailLine][0] == '#
               maxFailLine += 1
            for i in 1..maxFailLine-1
               line = lines[i][1..size(lines[i])-1]
               if line[0] == '+
                  j = indexOf(line ':)
                  line = f":"(maxFailLine+int(line[1..j-1]))""line[j..size(line)-1]
               expected = expected""line"\n"
               i += 1
         else if command[0] == '#target:
            targets = {}
            i = 1
            while i < size(command)
               targets = targets::{command[i]}
               i += 1
         else
            fail("Unknown command \""command[0]"\" while parsing "f)

      result = true
      i = 0
      rm(@tempcache)
      while result && i < size(targets)
         out exitcode = run(program '-f f targets[i] output:false)
         if expected ? exitcode && out[0] == "" && out[1] == expected : exitcode == 0 && out[0] == "PASS\n" && out[1] == ""
            i += 1
         else
            result = false
            if hasOutput
               echo("")
            echo("FAIL: "filename(f)""(size(targets) > 1 || targets[i] != 'default ? ":"targets[i] : ""))
            hasOutput = out[0] != "" || out[1] != ""
            if hasOutput
               if out[0]
                  echo(out[0] prefix:"> ")
               if out[1]
                  echo(out[1] prefix:"> ")
            if debug
               rm(@tempcache)
               j = 0
               while j < i
                  exec(program '-f f targets[j] fail:false echo:false echoStderr:false
                       env:{'XDG_CACHE_HOME @tempcache})
                  j += 1
               exec(gdb program '-f f targets[j] fail:false env:{'XDG_CACHE_HOME @tempcache})
      if result
         passcount += 1
      else
         failcount += 1
   if failcount
      echo("")
   echo("pass:  "passcount)
   echo("fail:  "failcount)
   if failcount
      fail(silent:true)

test:
   dotest()

vtest:
   valgrind = true
   dotest()

dbgtest:
   dotest(debug:true)

default:
   valgrind = true
   out exitcode = run(compile() '-f 'input)
   if exitcode
      fail()

prof:
   exec('valgrind '-q '--tool=callgrind compile(optimize:true) '-f 'input
        env:{'XDG_CACHE_HOME @tempcache})

gprof:
   p = compile(extraflags:'{-pg} linkflags:'{-pg} optimize:true)
   out exitcode = run(p '-f 'input)
   if exitcode
      fail()
   exec('gprof p)

strace:
   valgrind = false
   out exitcode = run('strace '-qvC compile() '-f 'input)
   if exitcode
      fail()

debug:
   program = compile()
   exec(gdb program '-f 'input env:{'XDG_CACHE_HOME @tempcache})

install:
   program = compile("/usr/local/share/don/" optimize:true)
   exec('rm '-f @/usr/local/bin/don)
   exec('rm '-rf @/usr/local/share/don)
   exec('mkdir @/usr/local/share/don/)
   exec('cp program @/usr/local/bin/)
   exec('cp @data/don.don @/usr/local/share/don/)
