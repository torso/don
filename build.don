valgrind = false
gdb = '{gdb -q --args}

fn compile(datadir:@data/, extraflags:{}, linkflags:{}, optimize:false)
{
    ofiles = cc(@src/*.c,
                flags:'{$("-DDATADIR=\""datadir"\"")
                        $(valgrind ? '-DVALGRIND : '-DNVALGRIND)
                        -ggdb3 -rdynamic -std=c89 -pedantic
                        -Wno-error=unused-parameter -Wno-error=unused-variable
                        -Wno-error=unused-function -Wall -Wextra -Wformat=2
                        -Winit-self -Wmissing-include-dirs -Wswitch-enum
                        -Wsync-nand -Wunused -Wstrict-overflow=5 -Wfloat-equal
                        -Wundef -Wshadow -Wunsafe-loop-optimizations
                        -Wbad-function-cast -Wc++-compat -Wcast-align
                        -Wwrite-strings -Wconversion -Wlogical-op
                        -Waggregate-return -Wstrict-prototypes
                        -Wold-style-definition -Wmissing-prototypes
                        -Wmissing-declarations -Wmissing-noreturn
                        -Wmissing-format-attribute -Wnormalized=nfc -Wpacked
                        -Wpacked-bitfield-compat -Wredundant-decls
                        -Wnested-externs -Wunreachable-code
                        -Wno-error=unreachable-code -Winline -Winvalid-pch
                        -Wdisabled-optimization -Wstack-protector -pipe
                        -march=native}::(optimize ? '{-O2} : '{-DDEBUG -O0})::extraflags)
    return link(ofiles, flags:linkflags, name:'don)
}

fn run(args..., output:true)
{
    if valgrind
    {
        logfile = @valgrind-log
        out exitcode = exec("valgrind", "-q", "--leak-check=full", "--show-reachable=yes",
                            "--log-file="logfile, args,
                            env:{'XDG_CACHE_HOME @tempcache},
                            fail:false, echo:output, echoStderr:output)
        log = read(logfile)
        rm(logfile)
        if (exitcode != 0 || contains(log, "** Assertion failed")) && !contains(log, "== Process terminating")
        {
            l = lines(log)
            log = ""
            copy = false
            for line in l
            {
                if startsWith(line, '*)
                {
                    log = log""line"\n"
                    copy = false
                }
                else
                {
                    if contains(line, "==    ") && copy
                    {
                        log = log""line"\n"
                    }
                    else
                    {
                        if contains(line, 'VALGRIND_PRINTF_BACKTRACE)
                        {
                            log = log""line"\n"
                            copy = true
                        }
                        else
                        {
                            copy = false
                        }
                    }
                }
            }
        }
        out = {out[0] out[1]""log}
        if output && log != ""
        {
            echo(log)
        }
    }
    else
    {
        out exitcode = exec(args, env:{'XDG_CACHE_HOME @tempcache},
                            fail:false, echo:output, echoStderr:output)
    }
    return out exitcode
}

fn dotest(program, debug:false)
{
    passcount = 0
    failcount = 0
    hasOutput = false
    for f in @test/*
    {
        test = read(f)
        targets = {'default}
        expected = null
        if test[0] == '#
        {
            lines = split(test, "\n")
            command = split(lines[0], " ")
            if command[0] == '#fail:
            {
                expected = ""
                maxFailLine = 1
                while maxFailLine < size(lines) && size(lines[maxFailLine]) && lines[maxFailLine][0] == '#
                {
                    maxFailLine += 1
                }
                for i in 1..maxFailLine-1
                {
                    line = lines[i][1..size(lines[i])-1]
                    if line[0] == '+
                    {
                        j = indexOf(line, ':)
                        line = f":"(maxFailLine+int(line[1..j-1]))""line[j..size(line)-1]
                    }
                    expected = expected""line"\n"
                    i += 1
                }
            }
            else if command[0] == '#target:
            {
                targets = {}
                i = 1
                while i < size(command)
                {
                    targets = targets::{command[i]}
                    i += 1
                }
            }
            else
            {
                fail("Unknown command \""command[0]"\" while parsing "f)
            }
        }

        result = true
        i = 0
        rm(@tempcache)
        while result && i < size(targets)
        {
            out exitcode = run(program, "-f", f, targets[i], output:false)
            if expected ? exitcode && out[0] == "" && out[1] == expected : exitcode == 0 && out[0] == "PASS\n" && out[1] == ""
            {
                i += 1
            }
            else
            {
                result = false
                if hasOutput
                {
                    echo("")
                }
                echo("FAIL: "filename(f)""(size(targets) > 1 || targets[i] != 'default ? ":"targets[i] : ""))
                hasOutput = out[0] != "" || out[1] != ""
                if hasOutput
                {
                    if out[0]
                    {
                        echo(out[0], prefix:"> ")
                    }
                    if out[1]
                    {
                        echo(out[1], prefix:"> ")
                    }
                }
                if debug
                {
                    rm(@tempcache)
                    j = 0
                    while j < i
                    {
                        exec(program, "-f", f, targets[j], fail:false, echo:false, echoStderr:false,
                             env:{'XDG_CACHE_HOME @tempcache})
                        j += 1
                    }
                    exec(gdb, program, "-f", f, targets[j], fail:false,
                         env:{'XDG_CACHE_HOME @tempcache})
                }
            }
        }
        if result
        {
            passcount += 1
        }
        else
        {
            failcount += 1
        }
    }
    if failcount
    {
        echo("")
    }
    echo("pass:  "passcount)
    echo("fail:  "failcount)
    if failcount
    {
        fail(silent:true)
    }
}

target test
{
    dotest(compile())
}

target vtest
{
    valgrind = true
    dotest(compile())
}

target dbgtest
{
    dotest(compile(), debug:true)
}

target covtest
{
    dotest(compile(extraflags:'{--coverage}, linkflags:'{--coverage}))
}

target default
{
    valgrind = true
    out exitcode = run(compile(), "-f", "input")
#    out exitcode = exec("time", compile(optimize:true), "test", env:'{XDG_CACHE_HOME tempcache2})
#    out exitcode = exec("time", "valgrind", "-q", "--tool=callgrind", "--collect-systime=yes", "--cache-sim=yes", "--branch-sim=yes", compile(optimize:true), "test", env:'{XDG_CACHE_HOME tempcache2})
    if exitcode
    {
        fail()
    }
}

target prof
{
    exec("valgrind", "-q", "--tool=callgrind", "--cache-sim=yes", "--branch-sim=yes", "--collect-systime=yes", compile(optimize:true), "-f", "input",
         env:{'XDG_CACHE_HOME @tempcache})
}

target gprof
{
    p = compile(extraflags:'{-pg}, linkflags:'{-pg}, optimize:true)
    out exitcode = run(p, "-f", "input")
    if exitcode
    {
        fail()
    }
    exec("gprof", p)
}

target strace
{
    valgrind = false
    out exitcode = run("strace", "-qvC", compile(), "-f", "input")
    if exitcode
    {
        fail()
    }
}

target debug
{
    exec("gdb", compile(), "-f", "input", env:{'XDG_CACHE_HOME @tempcache})
}

target disasm
{
    program = compile(optimize:true)
    exec("objdump", "-d", program)
}

target install
{
    program = compile("/usr/local/share/don/", optimize:true)
    exec("rm", "-f", @/usr/local/bin/don)
    exec("rm", "-rf", @/usr/local/share/don)
    exec("mkdir", @/usr/local/share/don/)
    exec("cp", program, @/usr/local/bin/)
    exec("cp", @data/don.don, @/usr/local/share/don/)
}

target b
{
    ofiles = cc(@test.c,
                flags:'{-ggdb3 -rdynamic
                        -Wno-error=unused-parameter -Wno-error=unused-variable
                        -Wno-error=unused-function -Wall -Wformat=2
                        -Winit-self -Wmissing-include-dirs -Wswitch-enum
                        -Wsync-nand -Wstrict-overflow=5 -Wfloat-equal
                        -Wundef -Wshadow -Wunsafe-loop-optimizations
                        -Wbad-function-cast -Wc++-compat -Wcast-align
                        -Wwrite-strings -Wconversion -Wlogical-op
                        -Waggregate-return -Wstrict-prototypes
                        -Wold-style-definition -Wmissing-prototypes
                        -Wmissing-declarations -Wmissing-noreturn
                        -Wmissing-format-attribute -Wnormalized=nfc -Wpacked
                        -Wpacked-bitfield-compat -Wredundant-decls
                        -Wnested-externs -Wunreachable-code
                        -Wno-error=unreachable-code -Winline -Winvalid-pch
                        -Wdisabled-optimization -Wstack-protector -pipe
                        -march=native -O2 -Wno-multichar})
    p = link(ofiles, name:'test)
    exec("time", p, 0)
#    exec("time", p, 1)
#    exec("time", p, 3)
#    exec("time", p, 7)
#    exec("time", p, 15)
#    exec("time", p, 31)
#    exec("time", p, 63)
#    exec("time", p, 127)
#    exec("time", p, 255)
#    exec("time", p, 511)
#    exec("time", p, 1023)
#    exec("time", p, 2047)
#    exec("time", p, 4095)
#    exec("time", p, 8191)
#    exec("time", p, 16383)
#    exec("time", p, 32767)
#    exec("time", p, 65535)
#    exec("time", p, 131071)
#    exec("time", p, 262143)
#    exec("time", p, 524287)
#    exec("time", p, 1048575)
}

target benchmark
{
    p = compile(optimize:true)
    rm(@tempcache)
#    exec('{cp -a tempcache2 tempcache})
#    run(args:'{time strace $p -f $@benchmark/build.don})
#    run(args:'{time $p -f $@benchmark/build.don partial})
#    run(args:'{time valgrind -q $p -f $@benchmark/build.don})
#    run(args:'{time gdb --args $p -f $@benchmark/build.don})
    run(args:'{time $p -f $@benchmark/build.don})
    run(args:'{time $p -f $@benchmark/build.don})
}

target benchmarkprof
{
    p = compile(optimize:true)
    rm(@tempcache)
#    exec('{cp -a tempcache2 tempcache})
    run(args:'{time valgrind -q --tool=callgrind --cache-sim=yes --branch-sim=yes --collect-systime=yes $p -f $@benchmark/build.don partial})
    run(args:'{time $p -f $@benchmark/build.don partial})
}
